--
-- PostgreSQL database dump
--

-- Dumped from database version 13.18
-- Dumped by pg_dump version 14.15 (Homebrew)

SET statement_timeout = 0;
SET lock_timeout = 0;
SET idle_in_transaction_session_timeout = 0;
SET client_encoding = 'UTF8';
SET standard_conforming_strings = on;
SELECT pg_catalog.set_config('search_path', '', false);
SET check_function_bodies = false;
SET xmloption = content;
SET client_min_messages = warning;
SET row_security = off;

--
-- Name: delivery_schema; Type: SCHEMA; Schema: -; Owner: -
--

CREATE SCHEMA delivery_schema;


--
-- Name: add_info(integer, integer, integer); Type: FUNCTION; Schema: delivery_schema; Owner: -
--

CREATE FUNCTION delivery_schema.add_info(p_order_id integer, p_product_id integer, p_quantity integer) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    INSERT INTO delivery_schema.Orderitems(order_id, product_id, quantity) VALUES (p_order_id, p_product_id, p_quantity);
EXCEPTION WHEN OTHERS THEN
    RAISE EXCEPTION 'Ошибка при добавлении пользователя: %', SQLERRM;
END;
$$;


--
-- Name: add_info(integer, character varying, integer); Type: FUNCTION; Schema: delivery_schema; Owner: -
--

CREATE FUNCTION delivery_schema.add_info(p_user_id integer, p_status character varying, p_total_cost integer DEFAULT 0) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    INSERT INTO delivery_schema.Orders(user_id, total_cost, status) VALUES (p_user_id, p_total_cost, p_status);
EXCEPTION WHEN OTHERS THEN
    RAISE EXCEPTION 'Ошибка при добавлении пользователя: %', SQLERRM;
END;
$$;


--
-- Name: add_info(character varying, text, integer, integer); Type: FUNCTION; Schema: delivery_schema; Owner: -
--

CREATE FUNCTION delivery_schema.add_info(p_name character varying, p_description text, p_price integer, p_stock integer) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    INSERT INTO delivery_schema.Products(name, description, price, stock) VALUES (p_name, p_description, p_price, p_stock);
EXCEPTION WHEN OTHERS THEN
    RAISE EXCEPTION 'Ошибка при добавлении пользователя: %', SQLERRM;
END;
$$;


--
-- Name: add_info(character varying, character varying, character varying, character varying); Type: FUNCTION; Schema: delivery_schema; Owner: -
--

CREATE FUNCTION delivery_schema.add_info(p_name character varying, p_email character varying, p_phone character varying, p_address character varying) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    INSERT INTO delivery_schema.Users(name, email, phone, address) VALUES (p_name, p_email, p_phone, p_address);
EXCEPTION WHEN OTHERS THEN
    RAISE EXCEPTION 'Ошибка при добавлении пользователя: %', SQLERRM;
END;
$$;


--
-- Name: calculate_total_cost(); Type: FUNCTION; Schema: delivery_schema; Owner: -
--

CREATE FUNCTION delivery_schema.calculate_total_cost() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
DECLARE
    current_total_cost INT;
BEGIN
    -- Пересчитываем общую стоимость
    SELECT COALESCE(SUM(p.price * oi.quantity), 0)
    INTO current_total_cost
    FROM delivery_schema.OrderItems oi
    JOIN delivery_schema.Products p ON oi.product_id = p.product_id
    WHERE oi.order_id = COALESCE(NEW.order_id, OLD.order_id); -- Для корректной работы с UPDATE и DELETE

    -- Обновляем поле total_cost
    UPDATE delivery_schema.Orders
    SET total_cost = current_total_cost
    WHERE order_id = COALESCE(NEW.order_id, OLD.order_id);

    -- Обновляем статус заказа в зависимости от total_cost
    IF current_total_cost > 0 THEN
        UPDATE delivery_schema.Orders
        SET status = 'Pending'
        WHERE order_id = COALESCE(NEW.order_id, OLD.order_id);
    ELSE
        UPDATE delivery_schema.Orders
        SET status = 'Created'
        WHERE order_id = COALESCE(NEW.order_id, OLD.order_id);
    END IF;

    RETURN NEW;
END;
$$;


--
-- Name: clear_all_tables(); Type: PROCEDURE; Schema: delivery_schema; Owner: -
--

CREATE PROCEDURE delivery_schema.clear_all_tables()
    LANGUAGE plpgsql
    AS $$
BEGIN
  DELETE FROM delivery_schema.users;
  DELETE FROM delivery_schema.orders;
  DELETE FROM delivery_schema.orderitems;
  DELETE FROM delivery_schema.products;
  RAISE NOTICE 'Таблицы в схеме my_schema очищены.';
EXCEPTION WHEN OTHERS THEN
  RAISE EXCEPTION 'Ошибка при очистке таблиц в схеме my_schema: %', SQLERRM;
END;
$$;


--
-- Name: clear_sertain_table(text); Type: PROCEDURE; Schema: delivery_schema; Owner: -
--

CREATE PROCEDURE delivery_schema.clear_sertain_table(t_name text)
    LANGUAGE plpgsql
    AS $$
DECLARE
  request TEXT;
BEGIN
  IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE TABLE_NAME = t_name) THEN
    RAISE EXCEPTION 'Таблица % не существует.', t_name;
  END IF;

  request := format('DELETE FROM %I;', t_name);
  EXECUTE request;
  RAISE NOTICE 'Таблица % очищена.', t_name;
EXCEPTION
  WHEN OTHERS THEN
    RAISE EXCEPTION 'Ошибка при очистке таблицы %: %', t_name, SQLERRM;
END;
$$;


--
-- Name: decrease_product_stock(); Type: FUNCTION; Schema: delivery_schema; Owner: -
--

CREATE FUNCTION delivery_schema.decrease_product_stock() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
    UPDATE Products
    SET stock = stock - NEW.quantity
    WHERE product_id = NEW.product_id;

    -- Проверяем, что stock не стал отрицательным
    IF (SELECT stock FROM Products WHERE product_id = NEW.product_id) < 0 THEN
        RAISE EXCEPTION 'Insufficient stock for product_id %', NEW.product_id;
    END IF;

    RETURN NEW;
END;
$$;


--
-- Name: delete_order_item(); Type: FUNCTION; Schema: delivery_schema; Owner: -
--

CREATE FUNCTION delivery_schema.delete_order_item() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
    -- Возвращаем товар на склад перед удалением строки
    UPDATE Products
    SET stock = stock + OLD.quantity
    WHERE product_id = OLD.product_id;

    -- Обновляем общую стоимость заказа
    UPDATE Orders 
    SET total_cost = total_cost - OLD.quantity * (SELECT price FROM Products WHERE product_id = OLD.product_id)
    WHERE order_id = OLD.order_id;

    -- Возвращаем NULL, чтобы позволить стандартное удаление строки
    RETURN OLD;
END;
$$;


--
-- Name: delete_products_by_desc(text); Type: PROCEDURE; Schema: delivery_schema; Owner: -
--

CREATE PROCEDURE delivery_schema.delete_products_by_desc(p_desc text)
    LANGUAGE plpgsql
    AS $$
DECLARE
  v_desc TEXT;
  rec RECORD;
BEGIN
  v_desc:= '%' || p_desc || '%';

  FOR rec IN SELECT product_id, name, description, price, stock
  FROM delivery_schema.Products
  WHERE description ILIKE v_desc
  LOOP
    DELETE FROM delivery_schema.Products;
  END LOOP;

EXCEPTION WHEN OTHERS THEN
  RAISE EXCEPTION 'Ошибка при поиске товаров: %', SQLERRM;
END;
$$;


--
-- Name: delete_specific_record(text, integer); Type: PROCEDURE; Schema: delivery_schema; Owner: -
--

CREATE PROCEDURE delivery_schema.delete_specific_record(t_name text, id integer)
    LANGUAGE plpgsql
    AS $$
BEGIN
    IF t_name = 'users' THEN
        DELETE FROM delivery_schema.Users WHERE user_id = id;
    ELSIF t_name = 'products' THEN
        DELETE FROM delivery_schema.Products WHERE product_id = id;
    ELSIF t_name = 'orderitems' THEN
        DELETE FROM delivery_schema.OrderItems WHERE order_item_id = id;
    ELSIF t_name = 'orders' THEN
        DELETE FROM delivery_schema.Orders WHERE order_id = id;
    ELSE
        RAISE EXCEPTION 'Table "%s" is not allowed for deletion.', t_name;
    END IF;

    RAISE NOTICE 'Record with id % from table % successfully deleted.', id, t_name;
EXCEPTION
    WHEN OTHERS THEN
        RAISE EXCEPTION 'Error while deleting record: %', SQLERRM;
END;
$$;


--
-- Name: drop_delivery_tables(); Type: PROCEDURE; Schema: delivery_schema; Owner: -
--

CREATE PROCEDURE delivery_schema.drop_delivery_tables()
    LANGUAGE plpgsql
    AS $$
BEGIN
    EXECUTE 'DROP SCHEMA IF EXISTS delivery_schema CASCADE';
END;
$$;


--
-- Name: search_products_by_desc(text); Type: FUNCTION; Schema: delivery_schema; Owner: -
--

CREATE FUNCTION delivery_schema.search_products_by_desc(p_desc text) RETURNS TABLE(product_id integer, name character varying, description text, price integer, stock integer)
    LANGUAGE plpgsql
    AS $$
BEGIN
    RETURN QUERY
    SELECT 
        p.product_id,
        p.name,
        p.description,
        p.price,
        p.stock
    FROM 
        delivery_schema.Products p
    WHERE 
        p.description ILIKE '%' || p_desc || '%';
END;
$$;


--
-- Name: show_tables_content(); Type: FUNCTION; Schema: delivery_schema; Owner: -
--

CREATE FUNCTION delivery_schema.show_tables_content() RETURNS TABLE(table_name text, row_content json)
    LANGUAGE plpgsql
    AS $$
DECLARE
    tbl_name TEXT;
BEGIN
    FOR tbl_name IN
        SELECT tablename
        FROM pg_tables
        WHERE schemaname = 'delivery_schema'
    LOOP
        RETURN QUERY EXECUTE FORMAT(
            'SELECT %L AS table_name, row_to_json(t) AS row_content FROM %I t',
            tbl_name,
            tbl_name
        );
    END LOOP;
END;
$$;


--
-- Name: update_cortege(integer, integer, character varying); Type: FUNCTION; Schema: delivery_schema; Owner: -
--

CREATE FUNCTION delivery_schema.update_cortege(p_order_id integer, p_user_id integer, p_status character varying) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    UPDATE delivery_schema.Orders
    SET status = p_status
    WHERE order_id = p_order_id;
    IF NOT FOUND THEN
        RAISE EXCEPTION 'Заказ с ID % не найден', p_order_id;
    END IF;
EXCEPTION WHEN OTHERS THEN
    RAISE EXCEPTION 'Ошибка при изменении заказа: %', SQLERRM;
END;
$$;


--
-- Name: update_cortege(integer, integer, integer, integer); Type: FUNCTION; Schema: delivery_schema; Owner: -
--

CREATE FUNCTION delivery_schema.update_cortege(p_order_item_id integer, p_order_id integer, p_product_id integer, p_quantity integer) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    UPDATE delivery_schema.OrderItems
    SET product_id = p_product_id, quantity = p_quantity
    WHERE order_item_id = p_order_item_id;
    IF NOT FOUND THEN
        RAISE EXCEPTION 'Продукт в заказе с ID % не найден', p_user_item_id;
    END IF;
EXCEPTION WHEN OTHERS THEN
    RAISE EXCEPTION 'Ошибка при добавлении продукта в заказе: %', SQLERRM;
END;
$$;


--
-- Name: update_cortege(integer, text, text, integer); Type: FUNCTION; Schema: delivery_schema; Owner: -
--

CREATE FUNCTION delivery_schema.update_cortege(p_product_id integer, p_name text, p_description text, p_stock integer) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    UPDATE delivery_schema.Products
    SET name = p_name, description = p_description, stock = p_stock
    WHERE product_id = p_product_id;
    IF NOT FOUND THEN
        RAISE EXCEPTION 'Продукт с ID % не найден', p_product_id;
    END IF;
EXCEPTION WHEN OTHERS THEN
    RAISE EXCEPTION 'Ошибка при добавлении продукта: %', SQLERRM;
END;
$$;


--
-- Name: update_cortege(integer, character varying, character varying, character varying, character varying); Type: FUNCTION; Schema: delivery_schema; Owner: -
--

CREATE FUNCTION delivery_schema.update_cortege(p_user_id integer, p_name character varying, p_email character varying, p_phone character varying, p_address character varying) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    UPDATE delivery_schema.Users
    SET name = p_name, email = p_email, phone = p_phone, address = p_address
    WHERE user_id = p_user_id;
    IF NOT FOUND THEN
        RAISE EXCEPTION 'Пользователь с ID % не найден', p_user_id;
    END IF;
EXCEPTION WHEN OTHERS THEN
    RAISE EXCEPTION 'Ошибка при изменении пользователя: %', SQLERRM;
END;
$$;


--
-- Name: update_product_stock(); Type: FUNCTION; Schema: delivery_schema; Owner: -
--

CREATE FUNCTION delivery_schema.update_product_stock() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
    IF NEW.quantity = 0 THEN
        -- Возвращаем товар на склад перед удалением строки
        UPDATE Products
        SET stock = stock + OLD.quantity
        WHERE product_id = OLD.product_id;

        -- Удаляем строку из OrderItems
        DELETE FROM OrderItems WHERE order_item_id = OLD.order_item_id;

        RETURN NULL; -- Указывает, что строка должна быть удалена
    END IF;

    -- Обновляем запасы на складе, если quantity изменилось
    UPDATE Products
    SET stock = stock + OLD.quantity - NEW.quantity
    WHERE product_id = NEW.product_id;

    -- Проверяем, что stock не стал отрицательным
    IF (SELECT stock FROM Products WHERE product_id = NEW.product_id) < 0 THEN
        RAISE EXCEPTION 'Insufficient stock for product_id %', NEW.product_id;
    END IF;

    RETURN NEW;
END;
$$;


SET default_tablespace = '';

SET default_table_access_method = heap;

--
-- Name: alembic_version; Type: TABLE; Schema: delivery_schema; Owner: -
--

CREATE TABLE delivery_schema.alembic_version (
    version_num character varying(32) NOT NULL
);


--
-- Name: orderitems; Type: TABLE; Schema: delivery_schema; Owner: -
--

CREATE TABLE delivery_schema.orderitems (
    order_item_id integer NOT NULL,
    order_id integer,
    product_id integer,
    quantity integer NOT NULL
);


--
-- Name: orderitems_order_item_id_seq; Type: SEQUENCE; Schema: delivery_schema; Owner: -
--

CREATE SEQUENCE delivery_schema.orderitems_order_item_id_seq
    AS integer
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: orderitems_order_item_id_seq; Type: SEQUENCE OWNED BY; Schema: delivery_schema; Owner: -
--

ALTER SEQUENCE delivery_schema.orderitems_order_item_id_seq OWNED BY delivery_schema.orderitems.order_item_id;


--
-- Name: orders; Type: TABLE; Schema: delivery_schema; Owner: -
--

CREATE TABLE delivery_schema.orders (
    order_id integer NOT NULL,
    user_id integer,
    order_date timestamp without time zone DEFAULT CURRENT_TIMESTAMP,
    total_cost integer DEFAULT 0,
    status character varying(20) NOT NULL
);


--
-- Name: orders_order_id_seq; Type: SEQUENCE; Schema: delivery_schema; Owner: -
--

CREATE SEQUENCE delivery_schema.orders_order_id_seq
    AS integer
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: orders_order_id_seq; Type: SEQUENCE OWNED BY; Schema: delivery_schema; Owner: -
--

ALTER SEQUENCE delivery_schema.orders_order_id_seq OWNED BY delivery_schema.orders.order_id;


--
-- Name: products; Type: TABLE; Schema: delivery_schema; Owner: -
--

CREATE TABLE delivery_schema.products (
    product_id integer NOT NULL,
    name character varying(100) NOT NULL,
    description text,
    price integer NOT NULL,
    stock integer NOT NULL
);


--
-- Name: products_product_id_seq; Type: SEQUENCE; Schema: delivery_schema; Owner: -
--

CREATE SEQUENCE delivery_schema.products_product_id_seq
    AS integer
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: products_product_id_seq; Type: SEQUENCE OWNED BY; Schema: delivery_schema; Owner: -
--

ALTER SEQUENCE delivery_schema.products_product_id_seq OWNED BY delivery_schema.products.product_id;


--
-- Name: users; Type: TABLE; Schema: delivery_schema; Owner: -
--

CREATE TABLE delivery_schema.users (
    user_id integer NOT NULL,
    name character varying(50) NOT NULL,
    email character varying(50),
    phone character varying(15) NOT NULL,
    address character varying(100) NOT NULL
);


--
-- Name: users_user_id_seq; Type: SEQUENCE; Schema: delivery_schema; Owner: -
--

CREATE SEQUENCE delivery_schema.users_user_id_seq
    AS integer
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: users_user_id_seq; Type: SEQUENCE OWNED BY; Schema: delivery_schema; Owner: -
--

ALTER SEQUENCE delivery_schema.users_user_id_seq OWNED BY delivery_schema.users.user_id;


--
-- Name: orderitems order_item_id; Type: DEFAULT; Schema: delivery_schema; Owner: -
--

ALTER TABLE ONLY delivery_schema.orderitems ALTER COLUMN order_item_id SET DEFAULT nextval('delivery_schema.orderitems_order_item_id_seq'::regclass);


--
-- Name: orders order_id; Type: DEFAULT; Schema: delivery_schema; Owner: -
--

ALTER TABLE ONLY delivery_schema.orders ALTER COLUMN order_id SET DEFAULT nextval('delivery_schema.orders_order_id_seq'::regclass);


--
-- Name: products product_id; Type: DEFAULT; Schema: delivery_schema; Owner: -
--

ALTER TABLE ONLY delivery_schema.products ALTER COLUMN product_id SET DEFAULT nextval('delivery_schema.products_product_id_seq'::regclass);


--
-- Name: users user_id; Type: DEFAULT; Schema: delivery_schema; Owner: -
--

ALTER TABLE ONLY delivery_schema.users ALTER COLUMN user_id SET DEFAULT nextval('delivery_schema.users_user_id_seq'::regclass);


--
-- Name: alembic_version alembic_version_pkc; Type: CONSTRAINT; Schema: delivery_schema; Owner: -
--

ALTER TABLE ONLY delivery_schema.alembic_version
    ADD CONSTRAINT alembic_version_pkc PRIMARY KEY (version_num);


--
-- Name: orderitems orderitems_pkey; Type: CONSTRAINT; Schema: delivery_schema; Owner: -
--

ALTER TABLE ONLY delivery_schema.orderitems
    ADD CONSTRAINT orderitems_pkey PRIMARY KEY (order_item_id);


--
-- Name: orders orders_pkey; Type: CONSTRAINT; Schema: delivery_schema; Owner: -
--

ALTER TABLE ONLY delivery_schema.orders
    ADD CONSTRAINT orders_pkey PRIMARY KEY (order_id);


--
-- Name: products products_pkey; Type: CONSTRAINT; Schema: delivery_schema; Owner: -
--

ALTER TABLE ONLY delivery_schema.products
    ADD CONSTRAINT products_pkey PRIMARY KEY (product_id);


--
-- Name: users users_email_key; Type: CONSTRAINT; Schema: delivery_schema; Owner: -
--

ALTER TABLE ONLY delivery_schema.users
    ADD CONSTRAINT users_email_key UNIQUE (email);


--
-- Name: users users_pkey; Type: CONSTRAINT; Schema: delivery_schema; Owner: -
--

ALTER TABLE ONLY delivery_schema.users
    ADD CONSTRAINT users_pkey PRIMARY KEY (user_id);


--
-- Name: lower_idx_product_name; Type: INDEX; Schema: delivery_schema; Owner: -
--

CREATE INDEX lower_idx_product_name ON delivery_schema.products USING btree (lower((name)::text));


--
-- Name: lower_idx_username; Type: INDEX; Schema: delivery_schema; Owner: -
--

CREATE INDEX lower_idx_username ON delivery_schema.users USING btree (lower((name)::text));


--
-- Name: orderitems calculate_total_cost_trigger; Type: TRIGGER; Schema: delivery_schema; Owner: -
--

CREATE TRIGGER calculate_total_cost_trigger AFTER INSERT OR DELETE OR UPDATE ON delivery_schema.orderitems FOR EACH ROW EXECUTE FUNCTION delivery_schema.calculate_total_cost();


--
-- Name: orderitems decrease_product_stock_trigger; Type: TRIGGER; Schema: delivery_schema; Owner: -
--

CREATE TRIGGER decrease_product_stock_trigger AFTER INSERT ON delivery_schema.orderitems FOR EACH ROW EXECUTE FUNCTION delivery_schema.decrease_product_stock();


--
-- Name: orderitems delete_order_item_trigger; Type: TRIGGER; Schema: delivery_schema; Owner: -
--

CREATE TRIGGER delete_order_item_trigger BEFORE DELETE ON delivery_schema.orderitems FOR EACH ROW EXECUTE FUNCTION delivery_schema.delete_order_item();


--
-- Name: orderitems update_product_stock_trigger; Type: TRIGGER; Schema: delivery_schema; Owner: -
--

CREATE TRIGGER update_product_stock_trigger BEFORE UPDATE ON delivery_schema.orderitems FOR EACH ROW EXECUTE FUNCTION delivery_schema.update_product_stock();


--
-- Name: orderitems orderitems_order_id_fkey; Type: FK CONSTRAINT; Schema: delivery_schema; Owner: -
--

ALTER TABLE ONLY delivery_schema.orderitems
    ADD CONSTRAINT orderitems_order_id_fkey FOREIGN KEY (order_id) REFERENCES delivery_schema.orders(order_id) ON DELETE CASCADE;


--
-- Name: orderitems orderitems_product_id_fkey; Type: FK CONSTRAINT; Schema: delivery_schema; Owner: -
--

ALTER TABLE ONLY delivery_schema.orderitems
    ADD CONSTRAINT orderitems_product_id_fkey FOREIGN KEY (product_id) REFERENCES delivery_schema.products(product_id) ON DELETE CASCADE;


--
-- Name: orders orders_user_id_fkey; Type: FK CONSTRAINT; Schema: delivery_schema; Owner: -
--

ALTER TABLE ONLY delivery_schema.orders
    ADD CONSTRAINT orders_user_id_fkey FOREIGN KEY (user_id) REFERENCES delivery_schema.users(user_id) ON DELETE CASCADE;


--
-- PostgreSQL database dump complete
--

